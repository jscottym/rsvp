generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id             String    @id @default(cuid())
  firebaseUid    String    @unique
  phone          String    @unique
  name           String
  nickname       String?
  inviteCode     String?   @unique
  smsConsent     Boolean   @default(false)
  smsConsentDate DateTime?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  // Relations
  organizedEvents      Event[]             @relation("EventOrganizer")
  rsvps                Rsvp[]
  ownedGroups          Group[]             @relation("GroupOwner")
  groupMemberships     GroupMember[]
  joinRequests         GroupJoinRequest[]
  activities           EventActivity[]
  createdNotifications EventNotification[] @relation("CreatedNotifications")

  @@index([firebaseUid])
  @@index([phone])
}

model Event {
  id            String   @id @default(cuid())
  slug          String   @unique
  title         String
  sportType     String
  description   String?
  location      String
  datetime      DateTime
  endDatetime   DateTime
  minPlayers    Int      @default(2)
  maxPlayers    Int
  allowSharing  Boolean  @default(true)
  sharingNote   String?
  timezone      String   @default("America/Denver")
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  organizerId   String
  organizer     User                @relation("EventOrganizer", fields: [organizerId], references: [id], onDelete: Cascade)
  rsvps         Rsvp[]
  activities    EventActivity[]
  notifications EventNotification[]

  @@index([slug])
  @@index([organizerId])
  @@index([datetime])
}

model Rsvp {
  id        String     @id @default(cuid())
  status    RsvpStatus
  comment   String?
  guestName String?
  guestPhone String?
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt

  // Relations
  eventId String
  event   Event  @relation(fields: [eventId], references: [id], onDelete: Cascade)
  userId  String?
  user    User?  @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@unique([eventId, userId])
  @@unique([eventId, guestPhone])
  @@index([eventId])
  @@index([userId])
}

enum RsvpStatus {
  IN
  OUT
  MAYBE
  IN_IF
  WAITLIST
}

enum EventActivityType {
  RSVP_IN
  RSVP_OUT
  RSVP_MAYBE
  RSVP_WAITLIST
  RSVP_IN_IF
  EVENT_EDITED
}

model EventActivity {
  id        String            @id @default(cuid())
  type      EventActivityType
  message   String
  comment   String?
  createdAt DateTime          @default(now())

  eventId   String
  event     Event             @relation(fields: [eventId], references: [id], onDelete: Cascade)
  userId    String?
  user      User?             @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([eventId, createdAt])
}

model Group {
  id          String          @id @default(cuid())
  name        String
  description String?
  type        GroupType       @default(STANDARD)
  visibility  GroupVisibility @default(PRIVATE)
  inviteCode  String?         @unique
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt

  // Relations
  ownerId      String
  owner        User               @relation("GroupOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  members      GroupMember[]
  joinRequests GroupJoinRequest[]

  @@index([ownerId])
  @@index([visibility])
}

enum GroupType {
  STANDARD
  MY_PEOPLE
}

enum GroupVisibility {
  PRIVATE
  PUBLIC
}

model GroupMember {
  id        String   @id @default(cuid())
  name      String
  phone     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  groupId String
  group   Group  @relation(fields: [groupId], references: [id], onDelete: Cascade)
  userId  String?
  user    User?  @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@unique([groupId, phone])
  @@index([groupId])
}

model GroupJoinRequest {
  id        String            @id @default(cuid())
  status    JoinRequestStatus @default(PENDING)
  message   String?
  createdAt DateTime          @default(now())
  updatedAt DateTime          @updatedAt

  // Relations
  groupId String
  group   Group  @relation(fields: [groupId], references: [id], onDelete: Cascade)
  userId  String
  user    User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([groupId, userId])
  @@index([groupId])
  @@index([userId])
  @@index([status])
}

enum JoinRequestStatus {
  PENDING
  APPROVED
  REJECTED
}

// ==================== Notification Models ====================

model EventNotification {
  id              String                   @id @default(cuid())
  eventId         String                   @unique // Only one reminder per event
  event           Event                    @relation(fields: [eventId], references: [id], onDelete: Cascade)

  // Scheduling
  scheduleType    NotificationScheduleType
  scheduledFor    DateTime
  relativeMinutes Int?

  // Content
  messageTemplate String?

  // Status
  status          NotificationStatus       @default(PENDING)
  processedAt     DateTime?

  createdAt       DateTime                 @default(now())
  createdById     String
  createdBy       User                     @relation("CreatedNotifications", fields: [createdById], references: [id])

  sentMessages    SentNotification[]

  @@index([scheduledFor, status])
}

enum NotificationScheduleType {
  NONE
  DAY_BEFORE
  HOURS_BEFORE
}

enum NotificationStatus {
  PENDING
  PROCESSING
  COMPLETED
  PARTIALLY_FAILED
  FAILED
  CANCELLED
}

model SentNotification {
  id               String                  @id @default(cuid())
  notificationId   String?
  notification     EventNotification?      @relation(fields: [notificationId], references: [id], onDelete: SetNull)

  phoneNumber      String
  recipientUserId  String?
  recipientName    String?                 // Store name for display

  messageBody      String
  twilioMessageSid String?
  twilioStatus     String?

  status           SentNotificationStatus  @default(PENDING)
  sentAt           DateTime?
  errorMessage     String?

  createdAt        DateTime                @default(now())

  @@index([twilioMessageSid])
  @@index([notificationId])
}

enum SentNotificationStatus {
  PENDING
  SENT
  DELIVERED
  FAILED
}

model InboundSms {
  id               String   @id @default(cuid())
  fromPhone        String
  toPhone          String
  messageBody      String
  twilioMessageSid String   @unique
  autoReplySent    Boolean  @default(false)
  createdAt        DateTime @default(now())

  @@index([fromPhone])
}
